.TH VELY 2vv $VERSION $DATE Development Tools
.SH NAME
Client_API \- Vely documentation (running_application)
.SH DESCRIPTION
You can use Vely C API client library to connect to a \fBFastCGI\fP application server, including Vely:

.RS 4
\[bu]    
The API has only one function, and that is "vv_fc_request()", which makes the call to the server.

.RE

.RS 4
\[bu]    
There is only a single data type used, which is "vv_fc" and it is used to specify request and its options, as well as to retrieve results.

.RE

.RS 4
\[bu]    
There is a single include file ("vfcgi.h"). 

.RE

.RS 4
\[bu]    
When building your client executable, you can specify build flags by using the result of "vv -i".
.RE

See Examples section below for detailed examples.

.LP
.B SENDING A REQUEST
.LP


.RS 4
.EX

int vv_fc_request (vv_fc *req);

.EE
.RE

All input and output parameters are contained in a single variable of type "vv_fc", the pointer to which is passed to "vv_fc_request()" function that runs a server request. This also has the advantage of forward compatibility because any future changes are contained in this type, and is also simple to use.

A variable of type "vv_fc" must be initialized to zero before using (such as with {0} initialization, "memset()" or "calloc()"), or otherwise some of its members may have random values:

.RS 4
.EX

// Define and initialize request variable
vv_fc req = {0};
// You could also do:
// memset ((char*)&req, 0, sizeof(vv_fc));
\[char46]..
int result = vv_fc_request (&req);

.EE
.RE


.B - Return value

The following are possible return values from "vv_fc_request()":

.RS 4
\[bu]    
VV_OKAY if request succeeded,

.RE

.RS 4
\[bu]    
VV_FC_ERR_RESOLVE_ADDR if host name for TCP connection cannot be resolved,

.RE

.RS 4
\[bu]    
VV_FC_ERR_PATH_TOO_LONG if path name of Unix socket is too long,

.RE

.RS 4
\[bu]    
VV_FC_ERR_SOCKET if cannot create a socket (for instance they are exhausted for the process or system),

.RE

.RS 4
\[bu]    
VV_FC_ERR_CONNECT if cannot connect to server (TCP or Unix alike),

.RE

.RS 4
\[bu]    
VV_FC_ERR_SOCK_WRITE if cannot write data to server (for instance if server has encountered an error or is down or if network connection is no longer available),

.RE

.RS 4
\[bu]    
VV_FC_ERR_SOCK_READ if cannot read data from server (for instance if server has encountered an error or is down or if network connection is no longer available),

.RE

.RS 4
\[bu]    
VV_FC_ERR_PROT_ERR if there is a protocol error, which indicates a FastCGI protocol issue on either or both sides,

.RE

.RS 4
\[bu]    
VV_FC_ERR_BAD_VER if either side does not support FastCGI protocol used by the other,

.RE

.RS 4
\[bu]    
VV_FC_ERR_SRV if server cannot complete the request,

.RE

.RS 4
\[bu]    
VV_FC_ERR_UNK if server does not recognize record types used by the client,

.RE

.RS 4
\[bu]    
VV_FC_ERR_OUT_MEM if client is out of memory,

.RE

.RS 4
\[bu]    
VV_FC_ERR_ENV_TOO_LONG if the combined length of all environment variables is too long,

.RE

.RS 4
\[bu]    
VV_FC_ERR_ENV_ODD if the number of supplied environment name/value pairs is incorrect,

.RE

.RS 4
\[bu]    
VV_FC_ERR_BAD_TIMEOUT if the value for timeout is incorrect,

.RE

.RS 4
\[bu]    
VV_FC_ERR_TIMEOUT if the request timed out based on "timeout" parameter or otherwise if the underlying Operating System libraries declared their own timeout.
.RE



.B - Server reply

The server replies with data that is split in two. One part is the actual result of processing (called "stdout" or standard output), and the other is the error messages (called "stderr" or standard error).

All Vely output goes to "stdout", except from \fBreport-error\fP and \fBpf-out\fP/\fBpf-url\fP/\fBpf-web\fP (with "to-error" clause) which goes to "stderr". The two outputs can be comingled in any way; the client will properly separate the two and present them as two messages in reply.

You can obtain server reply when it's ready in its entirety (likely most often used), or as it comes alone bit by bit (see more about asynchronous hooks futher here).

.LP
.B REQUEST TYPE (VV_FC)
.LP

Type "vv_fc" is defined as:

.RS 4
.EX

typedef struct {
    const char *fcgi_server; // the IP:port/socket_path to server
    const char *req_method; // request method
    const char *app_path; // application path
    const char *req; // request name
    const char *url_payload; // URL payload (path+query string)
    const char *content_type; // content type
    int content_len; // content len
    const char *req_body; // request body (i.e. content)
    char **env; // environment to pass into request on server side
    int timeout; // timeout for request
    int req_status; // status of request from server
    char *data; // actual response from server
    int data_len; // length of response from server
    char *error; // error message from server
    int error_len; // length of error from server
    // other elements used internally by Vely client
    vv_fc_out_hook out_hook; // hook to get output data as soon as it arrives
    vv_fc_err_hook err_hook; // hook get error data as soon as it arrives
} vv_fc;

.EE
.RE

Here is the more detailed explanation:

"fcgi_server" represents either a Unix socket or a TCP socket and is:

.RS 4
\[bu]    
for a Unix socket, a fully qualified name to a Unix socket file used to communicate with the server, or

.RE

.RS 4
\[bu]    
for a TCP socket, a host name and port name in the form of <host name>:<port number>, specifying where is the server listening on
.RE

"req_method" is a request method, such as GET, POST, PUT, DELETE or any other. Request method must be specified.

"app_path" is an application path (see \fBrequest_URL\fP). By default it's "/<application name>". Application path must be specified.

"req" is the request name preceded by a forward slash, as in "/<request name>" (see \fBrequest_URL\fP). Request name must be specified.

"url_payload" is the input parameters (as path segments and query string, see \fBrequest_URL\fP). URL payload can be NULL or empty, in which case it is not used.

"content_type" is the content type of request body (for instance it may be "application/json" or "image/jpg").

"content_len" is the length of request body in bytes.

"req_body" is the request body, which can be any text or binary data of length "content len". A request body is sent only if content type and request body are not NULL and not empty and content length is greater than zero.

"env" is any environment variables that should be passed along to the server. You can access those in Vely via "web-environment" clause of \fBget-sys\fP statement. This is an array of strings, where name/value pairs are specified one after the other, and which always must end with NULL. For example, if you want to use variable "REMOTE_USER" with value "John" and variable "MY_VARIABLE" with value "8000", then it might look like this:

.RS 4
.EX

char *env[5];
env[0] = "REMOTE_USER";
env[1] = "John"
env[2] = "MY_VARIABLE";
env[3] = "8000"
env[4] = NULL;

.EE
.RE

Thus, if you are passing N environment variables to the server, you must size "env" as "char*" array with 2*N+1 elements.

"timeout" is the number of seconds a request should not exceed. For instance if the remote server is taking too long or if the network connection is too slow, you can limit how long a request may take. If there is no timeout, then "timeout" value should be zero. Note that DNS resolution of the host name (in case you are using a TCP socket) is not counted in timeout. Maximum value for timeout is 86400.

"req_status" is the return status of server execution. This is a part of FastCGI specification and the particular server software you are using may or may not return the status. Vely server request returns status by means of \fBexit-code\fP statement.

"data" is the actual response from server as passed to stdout stream. In Vely, any output will go to "data", except when "to-error" clause is used in \fBpf-out\fP, \fBpf-url\fP and \fBpf-web\fP - use these constructs to output errors without stopping the request's execution. Additionaly, the output of \fBreport-error\fP will also not go to "data".

"data_len" is the length of "data" response from server in bytes. The response is always null-terminated as a courtesy, and "data_len" does not include the terminating null byte.

"error" is any error messages from a server response, i.e. data passed to stderr stream. It is comprised of any output when "to-error" clause is used in \fBpf-out\fP, \fBpf-url\fP and \fBpf-web\fP, as well as any output from \fBreport-error\fP. 

"error_len" is the length of "error" response from server in bytes. The response is always null-terminated as a courtesy, and "data_len" does not include the terminating null byte.

Note that stdout and stderr streams can be co-mingled, but the client will obtain them separately. This allows for clean separation of output from any error messages.

.LP
.B GETTING DATA REPLY (STDOUT)
.LP

See "data" and "data_len" members of "vv_fc" type above.

.LP
.B GETTING ERROR REPLY (STDERR)
.LP

See "error" and "error_len" members of "vv_fc" type above.

.LP
.B GETTING THE EXIT STATUS OF REQUEST
.LP

See "req_status" member of "vv_fc" type above.

.LP
.B FREEING THE RESULTS OF A REQUEST
.LP

Once you have obtained the results of a request, and when no longer needed, you should free them:

.RS 4
.EX

// Declare and initialize request variable
vv_fc req = {0};
// Setup the req variable
\[char46]..
// Execute request
vv_fc_request (&req);
// Free request output (data and error streams)
free (req.data);
free (req.error);

.EE
.RE

If you do not free the results of a request, your program may experience a memory leak. If your program exits right after issuing any request(s), you may skip freeing results as that is automatically done on exit by the Operating System. If you wish to save the results of multiple executions and process them later as a group, you can omit freeing them and save "req.data" (and/or "req.error") in some kind of an array for later processing; this way you do not have to copy the results unnecessarily.

.LP
.B ASYNCHRONOUS HOOKS
.LP

You can obtain the server's reply as it arrives by specifying read hooks. This is useful if the server supplies partial replies over a period of time, and your application can get those partial replies as they become available.

To specify a hook for output data (i.e. from stdout), you must write a C function with the following signature:

.RS 4
.EX

typedef void (*vv_fc_out_hook)(char *recv, int recv_len);

.EE
.RE

To specify a hook for error data (i.e. from stderr), you must write a C function with the following signature:

.RS 4
.EX

typedef void (*vv_fc_err_hook)(char *recv, int recv_len);

.EE
.RE

"recv" is the data received and "recv_len" is its length. To register these functions with "vv_fc_request()" function, assign their pointers to "out_hook" and "err_hook" members of request variable of type "vv_fc". Note that the output hook (i.e. hook function of type "vv_fc_out_hook") will receive empty string ("") in "recv" and "recv_len" will be 0 when the request has completed, meaning all data (including error) has been received.

For example, functions "get_output()" and "get_err()" will capture data as it arrives and print it out:

.RS 4
.EX

// Output hook
void get_output(char *d, int l)
{
    printf("Got output of [%.*s] of length [%d]", l, d, l);
}

// Error hook
void get_err(char *d, int l)
{
    printf("Got error of [%.*s] of length [%d]", l, d, l);
}

\[char46]..

vv_fc req = {0};
\[char46]..
// Register output and error hooks
req.out_hook = &get_out;
req.err_hook = &get_err;


.EE
.RE


.LP
.B MULTITHREADING
.LP

The FastCGI client is MT-safe, meaning you can use it both in single-threaded and multi-threaded programs. Note that each thread must have its own copy of "vv_fc" request variable, since it provides both input and output parameters to a request call and as such cannot be shared between the threads.

.SH EXAMPLES

.B - Simple example

The following example is a simple demonstration, with minimum of options used. Copy the C code to file "cli.c":

.RS 4
.EX

\[char35]include "vfcgi.h"

void main ()
{
  // Request type vv_fc - create a request variable and zero it out
  vv_fc req = {0};

  req.fcgi_server = "/var/lib/vv/helloworld/sock/sock"; // Unix socket
  req.req_method = "GET"; // GET HTTP method
  req.app_path = "/helloworld"; // application path
  req.req = "/hello-simple"; // request name

  // Make a request
  int res = vv_fc_request (&req);

  // Check return status, and if there's an error, display error code and the
  // corresponding error message. Otherwise, print out server response.
  if (res != VV_OKAY) printf ("Request failed [%d] [%s]\en", res, req.errm);
  else printf ("%s", req.data);

  // Free up resources so there are no memory leaks
  free (req.data);
  free (req.error);
}

.EE
.RE

To make this client application:

.RS 4
.EX

gcc -o cli cli.c -g $(vv -i)

.EE
.RE

In this case, you're using a Unix socket to communicate with the FastCGI server. To test with a Vely request handler, copy the following code to "hello_simple.vely" file:

.RS 4
.EX

\[char35]include "vely.h"
void hello_simple()
{
   silent-header
   out-header default

   @Hi there!
}

.EE
.RE

Create and make the Vely server application and run it via local Unix socket:

.RS 4
.EX

sudo vf -i -u $(whoami) helloworld
vv -q
vf -m quit helloworld
vf -w 1 helloworld

.EE
.RE

Run the FastCGI client:

.RS 4
.EX

\[char46]/cli

.EE
.RE

The output is, as expected:

.RS 4
.EX

Hi there!

.EE
.RE


.B - Example with more options

This example demonstrate using multiple options, including using TCP sockets connecting to a host and port number, environment variables, query string, request body and request execution timeout. It will also show the separation of "data" and "error" (i.e. stdout and stderr) streams from the server.

Copy this to file "cli1.c" - note that in this example FastCGI server will run on localhost (127.0.0.1) and TCP port 2301:

.RS 4
.EX

\[char35]include "vfcgi.h"

void main ()
{
   // Request type vv_fc - create a request variable
   vv_fc req;

   // Add 3 environment variables (in the form of name, value, name, value, ... , NULL)
   char *env[] = { "REMOTE_USER", "John", "SOME_VAR", "SOME\enVALUE", "NEW_VAR", "1000", NULL };

   // Create a request
   // Environment variables to pass to server request
   req.env = env;
   // Server IP and port
   req.fcgi_server = "127.0.0.1:2301";
   // Request method
   req.req_method = "GET";
   // Application path
   req.app_path = "/helloworld";
   // Request
   req.req = "/hello";
   // URL payload (path and query string)
   req.url_payload = "par1=val1&par2=91";
   // Content type
   req.content_type = "application/json";
   // Content (i.e. request body)
   req.req_body = "This is request body";
   // Content length
   req.content_len = strlen (req.req_body);
   // No timeout (set to 0)
   req.timeout = 0;

   // Make a request
   int res = vv_fc_request (&req);
   
   // Check return status, and if there's an error, display error code and the
   // corresponding error message
   if (res != VV_OKAY) printf("Request failed [%d] [%s]\en", res, req.errm);
   else {
       // If successful, display request results
       // Exit code from the server processing
       printf("Server status %d\en", req.req_status);
       // Length of reply from server
       printf("Len of data %d\en", req.data_len);
       // Length of any error from server
       printf("Len of error %d\en", req.error_len);
       // Reply from server
       printf("Data [%s]\en", req.data);
       // Any error message from server
       printf("Error [%s]\en", req.error);
   }

   // Free up resources so there are no memory leaks
  free (req.data);
  free (req.error);
}

.EE
.RE

Note that the URL payload (i.e. "req.url_payload") could have been written as a combination of a path segment and query string (see \fBrequest_URL\fP):

.RS 4
.EX

req.url_payload = "/par1/val1?par2=91";

.EE
.RE

or just as a path segment:

.RS 4
.EX

req.url_payload = "/par1/val1/par2/91";

.EE
.RE

To make this client application:

.RS 4
.EX

gcc -o cli1 cli1.c -g $(vv -i)

.EE
.RE

To test it, you can create a Vely server application. Copy this to "hello.vely" file in a separate directory:

.RS 4
.EX

\[char35]include "vely.h"

void hello()
{
    silent-header
    out-header default

    // Get request body
    request-body rb

    // Get environment variables passed on from the client
    get-sys web-environment "REMOTE_USER" to define ruser
    get-sys web-environment "SOME_VAR" to define somev
    get-sys web-environment "NEW_VAR" to define newv

    // Output, print the environment variables, the PID of server process and the request body received from the client
    @Hello World! [<<p-out ruser>>] [<<p-out somev>>] [<<p-out newv>>] [<<p-out newv>>] [<<p-out par1>>] <<pf-out "%d", getpid()>> <<p-out rb>>

    // Output back a number of lines, generally as "Output line #<num of line>"
    // After line #1418, print out "Line 1419 has an error" to stderr
    // After line #4418, report an error and exit
    // This demostrates outputting data to both stdout and stderr
    num i;
    for (i = 0; i < 8000; i++) {
        @Output line #<<p-num i>>
        if (i == 1419) {
            pf-out to-error "Line %lld has an error\en", i
        }
        if (i == 4419) {
            // Exit code of the server execution
            exit-code 82
            report-error "%s", "Some error!"
        }
    }
}

.EE
.RE

Create and make the Vely server application and run it on local TCP port 2301 to match the client above:

.RS 4
.EX

sudo vf -i -u $(whoami) helloworld
vv -q
vf -m quit helloworld
vf -w 1 -p 2301 helloworld

.EE
.RE

Run the FastCGI client:

.RS 4
.EX

\[char46]/cli1

.EE
.RE

The output:

.RS 4
.EX

Server status 82
Len of data 78517
Len of error 35
Data [Hello World! [John] [SOME
VALUE] [val1] [91] [1000] 11187 This is request body
Output line #0
Output line #1
Output line #2
Output line #3
Output line #4
Output line #5
Output line #6
Output line #7
\[char46]..
Output line #4413
Output line #4414
Output line #4415
Output line #4416
Output line #4417
Output line #4418
Output line #4419
]
Error [Line 1419 has an error
Some error!
]

.EE
.RE

The output shows server exit code (82, see \fBexit-code\fP in the Vely code above), length of output data, the output data which includes environment variables passed to the server from client, the PID of server process, the request body from the client, and then the error output. Note that the data output (stdout) and the error output (stderr) are separated, since FastCGI protocol does use separate streams over the same connection. This makes working with the output easy, while the data transfer is fast at the same time.
.SH SEE ALSO
 \fIRunning application\fP ( \fBapplication_setup\fP   \fBCGI\fP   \fBClient_API\fP   \fBcommand_line\fP   \fBcontainerize_application\fP   \fBFastCGI\fP   \fBFastCGI_client\fP   \fBplain_C_FCGI\fP  )  \fISEE ALL\fP (\fBdocumentation\fP)
