.TH VELY 2vv $VERSION $DATE Development Tools
.SH NAME
why_Vely \- Vely documentation (general)
.SH DESCRIPTION
The short answer to "Why Vely?" is performance and simplicity. What follows is a more qualified answer.

Vely was created to rapidly build server-side applications with maximum possible performance. 

While different people have entirely different notions of what that means, here it means simple statements that generate efficient and safe C code.

Such statements are written directly in C code and they perform a function that traditional API does, except they are simpler, more powerful and safer. In short, a Vely program is a C program with \fBstatement_APIs\fP that generate C. 

So the goal is to skew on the side of statement APIs, because it is safer, functionally richer and quicker to build applications; and to write C only as needed. 

And that can help with C's issues such as memory safety, being #1 such issue. Why? Because you'll get the best of C and skip the problematic part. What follows elaborates more on that.

Say you're using C mostly for variables and functions declarations, conditional and program flow statements, and for access to libraries. So pretty light stuff. 

And you're using statement APIs for heavy lifting, such as building strings, querying databases, outputting data, file manipulation, memory structures, program execution, encryption, encoding, JSON parsing, web stuff like cookies, input parameters, uploading and downloading files, request handling, daemonizing etc. - you get the picture, lots of stuff you need every day. Add to that the automatic memory allocation/garbage collector and automatic file closing for statement APIs. 

All of this is done with safety in mind, while pure C is more like "programming glue" that binds it together and provides a base for it. 

This setup clearly isn't safe; because C can still be used in any way you like. But it is \fIsafer\fP, and if you do things the \fIeasy\fP way, meaning you use the statement APIs wherever possible, then it is \fImuch safer\fP. And the resource utilization is likely to be better than anything else. 

.LP
.B VELY
.LP

So in a nutshell, Vely offers APIs in a form of easy to use statements. It generates C code for its \fBstatement_APIs\fP which are themselves written within C code. 

Vely statements look nothing like C though, or for that matter like many other popular languages. On one hand, they are simple. On the other, they are written inside C code so there is no need to learn anything new about the layer underneath; C is quite simple and well-known. 

Most of Vely statements generate a number of C statements. Still, their scope is typically narrow and the generated code is shallow and direct, similar to what an experienced C programmer would write, incurring virtually no loss of performance. Vely's design omits the classic API look and feel on purpose and focuses on simplicity. The arguments are specified in any order by naming their purpose. 

Vely is about practical, actual needs people have; it's about productivity, safety and performance. The idea is to not sacrifice performance at all, and to improve productivity and safety significantly.

.LP
.B WHY C?
.LP

Writing programs in C, if done properly, generally results in fastests and smallest programs, which is the reason why it's used in system and low-level programming. C is also the \fBgreenest programming language\fP.

When not done properly, C programs can cause memory issues with writing and reading out-of-bounds, which can be related to almost anything, such as memory allocation and usage, type conversion etc. and can manifest as safety issues and incorrect functioning.

Vely generates C underneath for several reasons. It is the shortest route to maximum performance and the smallest memory footprint. C is simple. It also allows usage of virtually any library in existence. And Vely statements are carefully crafted with the goal of generating fast and safe C code on their own and to provide memory garbage collection. Vely itself is written in C.

Vely's goal is not to write more C code, quite the opposite. By using Vely anywhere possible, C code can be used as a supporting mechanism for Vely statements, such as declaring variables, conditional statements, program flow and usage of external libraries. This drastically reduces the risk associated with C programming.  

.LP
.B WHAT IT IS, AND WHAT IT ISN'T
.LP

Vely is not a language. It is a better way to API. As a founding layer, C is a great compromise: rapid and easy development on top of a simple programming base with improved safety and arguably the best performance. 

This is especially true in the Cloud, where smaller and faster means less CPU seconds, less RAM, less money spent, less energy used and less emissions. And \fBMoore's law\fP may or may not be failing, but it will take significantly more funding, time and expenditure of all kinds to keep it going, and at some point it may no longer. 

In short, the goal of Vely is to lend the superior performance of C to general-purpose application development, and especially web applications. Regardless of what kind of hardware you run, or whatever kind of software you're designing, ultimately, performance matters. 

For a better feel on how Vely makes application development easier, safer and more productive, take a look at \fBexamples\fP.
.SH SEE ALSO
 \fIGeneral\fP ( \fBdeploying_application\fP   \fBhow_vely_works\fP   \fBquality_control\fP   \fBrename_files\fP   \fBSELinux\fP   \fBvely\fP   \fBvely_architecture\fP   \fBvely_removal\fP   \fBvf\fP   \fBvv\fP   \fBwhy_Vely\fP  )  \fISEE ALL\fP (\fBdocumentation\fP)
